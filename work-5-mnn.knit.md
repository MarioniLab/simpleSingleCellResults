---
title: Correcting batch effects in single-cell RNA-seq data
author: 
- name: Aaron T. L. Lun
  affiliation: Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
- name: Michael D. Morgan
  affiliation: Wellcome Trust Sanger Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SA, United Kingdom
date: "2018-11-10"
vignette: >
  %\VignetteIndexEntry{05. Correcting batch effects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---



# Introduction

Large single-cell RNA sequencing (scRNA-seq) projects usually need to generate data across multiple batches due to logistical constraints.
However, the processing of different batches is often subject to uncontrollable differences, e.g., changes in operator, differences in reagent quality.
This results in systematic differences in the observed expression in cells from different batches, which we refer to as "batch effects".
Batch effects are problematic as they can be major drivers of heterogeneity in the data, masking the relevant biological differences and complicating interpretation of the results.

Computational correction of these effects is critical for eliminating batch-to-batch variation, allowing data across multiple batches to be combined for valid downstream analysis.
However, existing methods such as `removeBatchEffect()` [@ritchie2015limma] assume that the composition of cell populations are either known or the same across batches.
This workflow describes the application of an alternative strategy for batch correction based on the detection of mutual nearest neighbours (MNNs) [@haghverdi2018batch].
The MNN approach does not rely on pre-defined or equal population compositions across batches, only requiring that a subset of the population be shared between batches.
We demonstrate its use on two human pancreas scRNA-seq datasets generated in separate studies.

# Processing the different datasets

## CEL-seq, GSE81076

### Loading in the data

This dataset was generated by @grun2016denovo using the CEL-seq protocol with unique molecular identifiers (UMIs) and ERCC spike-ins.
Count tables were obtained from the NCBI Gene Expression Omnibus using the accession number above.


```r
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
grun.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE81nnn/GSE81076/suppl/GSE81076%5FD2%5F3%5F7%5F10%5F17%2Etxt%2Egz"))
```

We first read the table into memory.


```r
gse81076.df <- read.table(grun.fname, sep='\t', 
    header=TRUE, stringsAsFactors=FALSE, row.names=1)
dim(gse81076.df)
```

```
## [1] 20148  1728
```

Unfortunately, the data and metadata are all mixed together in this file.
As a result, we need to manually extract the metadata from the column names.


```r
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse81076.df))
table(donor.names)
```

```
## donor.names
##    D101    D102  D10631     D17   D1713 D172444      D2      D3     D71 
##      96      96      96     288      96      96      96     480      96 
##     D72     D73     D74 
##      96      96      96
```

```r
plate.id <- sub("^D[0-9]+(.*)_.*", "\\1", colnames(gse81076.df))
table(plate.id)
```

```
## plate.id
##      All1 All2  en1  en2  en3  en4   ex TGFB 
##  864   96   96   96   96   96   96  192   96
```

Another irritating feature of this dataset is that gene symbols were supplied, rather than stable identifiers such as Ensembl.
We convert all row names to Ensembl identifiers, removing `NA` or duplicated entries (with the exception of spike-in transcripts). 


```r
gene.symb <- gsub("__chr.*$", "", rownames(gse81076.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
```

```
## is.spike
## FALSE  TRUE 
## 20064    84
```

```r
library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse81076.df <- gse81076.df[keep,]
rownames(gse81076.df) <- gene.ids[keep]
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical    2071   18077
```

We create a `SingleCellExperiment` object to store the counts and metadata together.
This reduces the risk of book-keeping errors in later steps of the analysis.
Note that we re-identify the spike-in rows, as the previous indices would have changed after the subsetting.


```r
library(SingleCellExperiment)
sce.gse81076 <- SingleCellExperiment(list(counts=as.matrix(gse81076.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse81076, "ERCC") <- grepl("^ERCC-", rownames(gse81076.df)) 
sce.gse81076  
```

```
## class: SingleCellExperiment 
## dim: 18077 1728 
## metadata(0):
## assays(1): counts
## rownames(18077): ENSG00000268895 ENSG00000121410 ... ENSG00000074755
##   ENSG00000036549
## rowData names(1): Symbol
## colnames(1728): D2ex_1 D2ex_2 ... D17TGFB_95 D17TGFB_96
## colData names(2): Donor Plate
## reducedDimNames(0):
## spikeNames(1): ERCC
```

### Quality control and normalization

We compute quality control (QC) metrics for each cell [@mccarthy2017scater] and identify cells with low library sizes, low numbers of expressed genes, or high ERCC content.


```r
library(scater)
sce.gse81076 <- calculateQCMetrics(sce.gse81076, compact=TRUE)
QC <- sce.gse81076$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

```
##   LowLib LowNgenes HighSpike
## 1     55       130       388
```

Cells with extreme values for these QC metrics are presumed to be of low quality and are removed.
A more thorough analysis would examine the distributions of these QC metrics beforehand, but we will skip that step for brevity here.


```r
discard <- low.lib | low.genes | high.spike
sce.gse81076 <- sce.gse81076[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    1292     436
```

We compute size factors for the endogenous genes using the pooling method [@lun2016pooling].


```r
library(scran)
set.seed(1000)    
sce.gse81076 <- simpleSumFactors(sce.gse81076, min.mean=0.1, approximate=TRUE)
summary(sizeFactors(sce.gse81076))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.01505 0.45454 0.80960 1.00000 1.30065 7.43162
```

We also compute size factors for the spike-in transcripts [@lun2017assessing].
Recall that we set `general.use=FALSE` to ensure that the spike-in size factors are only applied to the spike-in transcripts.


```r
sce.gse81076 <- computeSpikeFactors(sce.gse81076, general.use=FALSE)
summary(sizeFactors(sce.gse81076, "ERCC"))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.01042 0.57782 0.88699 1.00000 1.27765 7.43998
```

We then compute normalized log-expression values for use in downstream analyses.


```r
sce.gse81076 <- normalize(sce.gse81076)
```

### Identifying highly variable genes

We identify highly variable genes (HVGs) using `trendVar()` and `decomposeVar()`, using the variances of spike-in transcripts to model technical noise.
We set `block=` to ensure that uninteresting differences between plates or donors do not inflate the variance.
The small discrepancy in the fitted trend in Figure \@ref(fig:var-gse81076) is caused by the fact that the trend is fitted robustly to the block-wise variances of the spike-ins, 
while the variances shown are averaged across blocks and not robust to outliers.


```r
block <- paste0(sce.gse81076$Plate, "_", sce.gse81076$Donor)
fit <- trendVar(sce.gse81076, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse81076, fit)

plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse81076)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/var-gse81076-1.png" alt="Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)." width="100%" />
<p class="caption">(\#fig:var-gse81076)Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).</p>
</div>

We order genes by decreasing biological component, revealing some usual suspects such as insulin and glucagon.
We will be using this information later when performing feature selection prior to running `mnnCorrect()`.


```r
dec.gse81076 <- dec
dec.gse81076$Symbol <- rowData(sce.gse81076)$Symbol
dec.gse81076 <- dec.gse81076[order(dec.gse81076$bio, decreasing=TRUE),]
head(dec.gse81076)
```

```
## DataFrame with 6 rows and 7 columns
##                             mean            total              bio
##                        <numeric>        <numeric>        <numeric>
## ENSG00000254647 2.80443757119854 6.10588718378184  5.6614003792502
## ENSG00000129965 1.86089532974054 5.76583825597333 5.31790792732777
## ENSG00000115263 3.97238457747484 5.50022799061621 5.26792027365823
## ENSG00000118271 3.62059046694063 5.47893502225471 5.17159561829033
## ENSG00000115386 4.18911248455184 5.31046529940648  5.0710332050704
## ENSG00000164266 3.00255241344342 5.30908800742638 4.89602691861382
##                              tech   p.value       FDR      Symbol
##                         <numeric> <numeric> <numeric> <character>
## ENSG00000254647 0.444486804531633         0         0         INS
## ENSG00000129965  0.44793032864556         0         0    INS-IGF2
## ENSG00000115263 0.232307716957985         0         0         GCG
## ENSG00000118271  0.30733940396438         0         0         TTR
## ENSG00000115386 0.239432094336088         0         0       REG1A
## ENSG00000164266 0.413061088812563         0         0      SPINK1
```



## CEL-seq2, GSE85241

### Loading in the data

This dataset was generated by @muraro2016singlecell using the CEL-seq2 protocol with unique molecular identifiers (UMIs) and ERCC spike-ins.
Count tables were obtained from the NCBI Gene Expression Omnibus using the accession number above.


```r
muraro.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE85nnn/GSE85241/suppl",
    "GSE85241%5Fcellsystems%5Fdataset%5F4donors%5Fupdated%2Ecsv%2Egz"))
```

We first read the table into memory.


```r
gse85241.df <- read.table(muraro.fname, sep='\t', 
    header=TRUE, row.names=1, stringsAsFactors=FALSE)
dim(gse85241.df)
```

```
## [1] 19140  3072
```

We extract the metadata from the column names.


```r
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse85241.df))
table(donor.names)
```

```
## donor.names
## D28 D29 D30 D31 
## 768 768 768 768
```

```r
plate.id <- sub("^D[0-9]+\\.([0-9]+)_.*", "\\1", colnames(gse85241.df))
table(plate.id)
```

```
## plate.id
##   1   2   3   4   5   6   7   8 
## 384 384 384 384 384 384 384 384
```

Yet again, gene symbols were supplied instead of Ensembl or Entrez identifiers.
We convert all row names to Ensembl identifiers, removing `NA` or duplicated entries (with the exception of spike-in transcripts). 


```r
gene.symb <- gsub("__chr.*$", "", rownames(gse85241.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)
```

```
## is.spike
## FALSE  TRUE 
## 19059    81
```

```r
library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse85241.df <- gse85241.df[keep,]
rownames(gse85241.df) <- gene.ids[keep]
summary(keep)
```

```
##    Mode   FALSE    TRUE 
## logical    1949   17191
```

We create a `SingleCellExperiment` object to store the counts and metadata together.


```r
sce.gse85241 <- SingleCellExperiment(list(counts=as.matrix(gse85241.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse85241, "ERCC") <- grepl("^ERCC-", rownames(gse85241.df)) 
sce.gse85241  
```

```
## class: SingleCellExperiment 
## dim: 17191 3072 
## metadata(0):
## assays(1): counts
## rownames(17191): ENSG00000268895 ENSG00000121410 ... ENSG00000074755
##   ENSG00000036549
## rowData names(1): Symbol
## colnames(3072): D28.1_1 D28.1_2 ... D30.8_95 D30.8_96
## colData names(2): Donor Plate
## reducedDimNames(0):
## spikeNames(1): ERCC
```

### Quality control and normalization

We compute QC metrics for each cell and identify cells with low library sizes, low numbers of expressed genes, or high ERCC content.


```r
sce.gse85241 <- calculateQCMetrics(sce.gse85241, compact=TRUE)
QC <- sce.gse85241$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

```
##   LowLib LowNgenes HighSpike
## 1    577       669       696
```

Low-quality cells are defined as those with extreme values for these QC metrics and are removed.


```r
discard <- low.lib | low.genes | high.spike
sce.gse85241 <- sce.gse85241[,!discard]
summary(discard)
```

```
##    Mode   FALSE    TRUE 
## logical    2346     726
```

We compute size factors for the endogenous genes and spike-in transcripts, and use them to compute log-normalized expression values.


```r
set.seed(1000)
sce.gse85241 <- simpleSumFactors(sce.gse85241, min.mean=0.1, approximate=TRUE)
summary(sizeFactors(sce.gse85241))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0789  0.5474  0.8259  1.0000  1.2151 13.6699
```

```r
sce.gse85241 <- computeSpikeFactors(sce.gse85241, general.use=FALSE)
summary(sizeFactors(sce.gse85241, "ERCC"))
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.09295 0.61309 0.88902 1.00000 1.27519 4.04643
```

```r
sce.gse85241 <- normalize(sce.gse85241)
```

### Identifying highly variable genes

We fit a trend to the spike-in variances as previously described, allowing us to model the technical noise for each gene (Figure \@ref(fig:var-gse85241)).
Again, we set `block=` to ensure that uninteresting differences between plates or donors do not inflate the variance.


```r
block <- paste0(sce.gse85241$Plate, "_", sce.gse85241$Donor)
fit <- trendVar(sce.gse85241, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse85241, fit)
plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse85241)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/var-gse85241-1.png" alt="Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)." width="100%" />
<p class="caption">(\#fig:var-gse85241)Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red).</p>
</div>

We order genes by decreasing biological component, as described above.


```r
dec.gse85241 <- dec
dec.gse85241$Symbol <- rowData(sce.gse85241)$Symbol
dec.gse85241 <- dec.gse85241[order(dec.gse85241$bio, decreasing=TRUE),]
head(dec.gse85241)
```

```
## DataFrame with 6 rows and 7 columns
##                             mean            total              bio
##                        <numeric>        <numeric>        <numeric>
## ENSG00000115263 7.65807643621929 6.61750855587646 6.58864647624195
## ENSG00000089199  4.6184680690989 6.41445571426988 6.29247034767915
## ENSG00000169903 3.01326304648171  6.5395518200798 6.18472046552923
## ENSG00000254647 2.00151038901661 6.40130132621179 5.84521274745049
## ENSG00000118271 7.33108862683239 5.77095728458802 5.73945924146402
## ENSG00000171951 4.18778479052864  5.5593871260377 5.39442164898793
##                               tech   p.value       FDR      Symbol
##                          <numeric> <numeric> <numeric> <character>
## ENSG00000115263 0.0288620796345149         0         0         GCG
## ENSG00000089199  0.121985366590727         0         0        CHGB
## ENSG00000169903  0.354831354550577         0         0      TM4SF4
## ENSG00000254647  0.556088578761307         0         0         INS
## ENSG00000118271 0.0314980431239984         0         0         TTR
## ENSG00000171951  0.164965477049769         0         0        SCG2
```



## Comments on additional batches

In @haghverdi2018batch, we originally performed batch correction across four separate pancreas scRNA-seq datasets.
For simplicity, we will only consider the two batches generated using CEL-seq(2) and ignore those generated using Smart-seq2 [@segerstolpe2016singlecell;@lawlor2017singlecell].
As one might expect, batch correction is easiest when dealing with data generated from the same technology,
as fewer systematic differences are present that can interfere with the biological structure.
Nonetheless, it is often possible to obtain good results when applying MNN correction to batches of data generated with different technologies.

It is also worth pointing out that both of the CEL-seq(2) batches above contain cells from multiple donors.
Each donor could be treated as a separate batch in their own right, 
reflecting (presumably uninteresting) biological differences between donors due to genotype, age, sex or other factors that are not easily controlled when dealing with humans.
For simplicity, we will ignore the donor effects within each study and only consider the removal of the batch effect between the two studies.
However, we note that it is possible to apply the MNN correction between donors in each batch and then between the batches - see `?fastMNN` for details.

# Feature selection across batches

To obtain a single set of features for batch correction, we compute the average biological component across all batches.
We then take all genes with positive biological components to ensure that all interesting biology is retained, equivalent to the behaviour of `denoisePCA()`.
However, the quality of the correction can often be sensitive to technical noise, which means that some discretion may be required during feature selection.
Users may prefer to take the top 1000-5000 genes with the largest average components, or to use `combineVar()` to obtain combined _p_-values for gene selection.


```r
universe <- intersect(rownames(dec.gse85241), rownames(dec.gse81076))
mean.bio <- (dec.gse85241[universe,"bio"] + dec.gse81076[universe,"bio"])/2
chosen <- universe[mean.bio > 0]
length(chosen)
```

```
## [1] 14570
```

We also rescale each batch to adjust for differences in sequencing depth between batches.
The `multiBatchNorm()` function recomputes log-normalized expression values after adjusting the size factors for systematic differences in coverage between `SingleCellExperiment` objects.
(Keep in mind that the previously computed size factors only remove biases between cells _within_ a single batch.)
This improves the quality of the correction by removing one aspect of the technical differences between batches.


```r
rescaled <- multiBatchNorm(sce.gse85241[universe,], sce.gse81076[universe,])
rescaled.gse85241 <- rescaled[[1]]
rescaled.gse81076 <- rescaled[[2]]
```

**Comments from Aaron:**

- Technically, we should have performed variance modelling and feature selection _after_ calling `multiBatchNorm()`.
This ensures that the variance components are estimated from the same values to be used in the batch correction.
In practice, this makes little difference, and it tends to be easier to process each batch separately and consolidate all results in one step as shown above.

# Performing MNN-based correction

Consider a cell $a$ in batch $A$, and identify the cells in batch $B$ that are nearest neighbours to $a$ in the expression space defined by the selected features.
Repeat this for a cell $b$ in batch $B$, identifying its nearest neighbours in $A$.
Mutual nearest neighbours are pairs of cells from different batches that belong in each other's set of nearest neighbours.
The reasoning is that MNN pairs represent cells from the same biological state prior to the application of a batch effect - see @haghverdi2018batch for full theoretical details.
Thus, the difference between cells in MNN pairs can be used as an estimate of the batch effect, the subtraction of which can yield batch-corrected values.

We apply the `fastMNN()` function to the three batches to remove the batch effect, using the genes in `chosen`.
To reduce computational work and technical noise, all cells in all cells are projected into the low-dimensional space defined by the top `d` principal components.
Identification of MNNs and calculation of correction vectors are then performed in this low-dimensional space.
The function returns a matrix of corrected values for downstream analyses like clustering or visualization.


```r
set.seed(100) 
original <- list(
    GSE81076=logcounts(rescaled.gse81076)[chosen,],
    GSE85241=logcounts(rescaled.gse85241)[chosen,]
)

# Slightly convoluted call to avoid re-writing code later.
# Equivalent to fastMNN(GSE81076, GSE85241, k=20, d=50, approximate=TRUE)
mnn.out <- do.call(fastMNN, c(original, list(k=20, d=50, approximate=TRUE)))
dim(mnn.out$corrected)
```

```
## [1] 3638   50
```

Each row of the `corrected` matrix corresponds to a cell in one of the batches.
The `batch` field contains a run-length encoding object specifying the batch of origin of each row.


```r
mnn.out$batch
```

```
## character-Rle of length 3638 with 2 runs
##   Lengths:       1292       2346
##   Values : "GSE81076" "GSE85241"
```

Advanced users may also be interested in the list of `DataFrame`s in the `pairs` field.
Each `DataFrame` describes the MNN pairs identified upon merging of each successive batch.
This may be useful for checking the identified MNN pairs against known cell type identity, e.g., to determine if the cell types are being paired correctly.


```r
mnn.out$pairs
```

```
## [[1]]
## DataFrame with 6661 rows and 2 columns
##          first    second
##      <integer> <integer>
## 1            1      1794
## 2            1      2087
## 3           15      1612
## 4           15      2512
## 5           15      2575
## ...        ...       ...
## 6657      1290      2339
## 6658      1290      2794
## 6659      1290      2731
## 6660      1290      1538
## 6661      1290      2001
```

As previously mentioned, we have only used two batches here to simplify the workflow.
However, the MNN approach is not limited to two batches, and inclusion of more batches is as simple as adding more `SingleCellExperiment` objects to the `fastMNN()` call.

**Comments from Aaron:**

- The `k=` parameter specifies the number of nearest neighbours to consider when defining MNN pairs.
This should be interpreted as the minimum frequency of each cell type or state in each batch.
Larger values will improve the precision of the correction by increasing the number of MNN pairs, 
at the cost of reducing accuracy by allowing MNN pairs to form between cells of different type.
- When `approximate=TRUE`, `fastMNN()` uses methods from the *[irlba](https://CRAN.R-project.org/package=irlba)* package to perform the principal components analysis quickly.
While the run-to-run differences should be minimal, it does mean that `set.seed()` is required to obtain fully reproducible results.




# Controlling the merge order

## Manual specification 

The order of the supplied batches will affect the result as the first batch is used to define the reference space to which all other batches are corrected.
Specifically, the first batch is defined as the reference batch;
the second batch is corrected to and merged with the current reference batch, yielding a new reference batch;
and so on for all batches in the supplied order, with an increasingly large reference batch at each step.
The use of a merged reference ensures that information from batches other than the first are used to identify MNN pairs in later batches.

The order of batches to merge can be manually specified in the `auto.order=` argument to `fastMNN()`.
In the example shown below, batch 2 is treated as the reference as it is the first specified batch in `auto.order=`.
The first batch is then corrected to the second batch to obtain a new reference batch - and so on, if more than two batches were present.


```r
mnn.out2 <- do.call(fastMNN, c(original, 
    list(k=20, d=50, approximate=TRUE, auto.order=c(2,1))
))
mnn.out2$order # batch 2 (GSE85241) is first in the order.
```

```
## [1] "GSE85241" "GSE81076"
```

```r
mnn.out2$pairs # 'first' cells now come from GSE85241.
```

```
## [[1]]
## DataFrame with 6661 rows and 2 columns
##          first    second
##      <integer> <integer>
## 1         1294       748
## 2         1294       963
## 3         1294       635
## 4         1294      1206
## 5         1294       921
## ...        ...       ...
## 6657      3638       866
## 6658      3638       597
## 6659      3638      1188
## 6660      3638      1197
## 6661      3638      1274
```

Using `auto.order=` will change the merge order without requiring a change to the supplied order of batches in `original`.
Similarly, the order of batches (and cells) in the output will not be altered.
This makes it easy to explore different merge orders without altering the surrounding code.


```r
mnn.out2$batch # same as mnn.out$batch
```

```
## character-Rle of length 3638 with 2 runs
##   Lengths:       1292       2346
##   Values : "GSE81076" "GSE85241"
```

If very different batches (in terms of cell composition) are present, we suggest setting the largest and/or most heterogeneous batch as the first.
This ensures that sufficient MNN pairs will be identified between the first and other batches for stable correction.



## Hierarchical merging 

In more complex experiments, we may know beforehand that certain sets of batches are more similar to each other.
For example, we might want to merge batches that represent replicate experiments from the same condition, prior to merging across conditions.
We might also want to merge batches generated with the same scRNA-seq technology prior to merging across technologies.
This can be done by multiple calls to `fastMNN()` with progressively merged batches.

To illustrate, assume that we want to remove `Donor` effects within each batch prior to merging across batches.
The first step is to use the `multiBatchPCA()` function to perform a PCA across _all_ batches to be merged.
This ensures that all cells are placed onto the same coordinate space, which would obviously not be possible if a PCA was performed for each batch separately.


```r
set.seed(1000) # for irlba.
scaled <- lapply(original, cosineNorm) # for consistency with fastMNN() defaults.
output <- do.call(multiBatchPCA, c(scaled, list(d=50, approximate=TRUE)))
names(output)
```

```
## [1] "GSE81076" "GSE85241"
```

```r
dim(output$GSE85241)
```

```
## [1] 2346   50
```

```r
dim(output$GSE81076)
```

```
## [1] 1292   50
```

We split the cells in GSE85241 by the donor of origin, yielding one matrix of PC scores per donor in `by.donor`.


```r
all.donors <- unique(rescaled.gse85241$Donor)
table(rescaled.gse85241$Donor)
```

```
## 
## D28 D29 D30 D31 
## 340 604 689 713
```

```r
by.donor <- vector("list", length(all.donors))
names(by.donor) <- sort(all.donors)
for (x in all.donors) {
    by.donor[[x]] <- output$GSE85241[rescaled.gse85241$Donor==x,]
}
```

We pass these matrices to `fastMNN()`, setting `pc.input=TRUE` to indicate that dimensionality reduction has already been performed.
This uses the first donor to define the reference space^[Which can be changed with `auto.order=`, if so desired.] and merges cells from all other donors to the first.
In this manner, we can remove donor effects within the GSE85241 batch.


```r
mnn.out.85241 <- do.call(fastMNN, c(by.donor, list(pc.input=TRUE)))
mnn.out.85241$batch
```

```
## character-Rle of length 2346 with 4 runs
##   Lengths:   340   604   689   713
##   Values : "D28" "D29" "D30" "D31"
```

We repeat this process for GSE86071.
For demonstration purposes, we will aggregate some of the donors together to ensure that there are enough cells in each level for MNN detection.


```r
adj.donors <- c(D101="A", D102="A", D10631="A",
    D17="B", D1713="B", D172444="B",
    D2="C", D3="C",
    D71="D", D72="D", D73="D", D74="D")[rescaled.gse81076$Donor]
table(adj.donors)
```

```
## adj.donors
##   A   B   C   D 
## 162 464 320 346
```

```r
all.donors <- unique(adj.donors)
by.donor <- vector("list", length(all.donors))
names(by.donor) <- sort(all.donors)
for (x in all.donors) {
    by.donor[[x]] <- output$GSE81076[adj.donors==x,]
}

mnn.out.81076 <- do.call(fastMNN, c(by.donor, list(pc.input=TRUE)))
mnn.out.81076$batch
```

```
## character-Rle of length 1292 with 4 runs
##   Lengths: 162 464 320 346
##   Values : "A" "B" "C" "D"
```

The next step is to merge the two batches together.
To do this, we simply repeat the `fastMNN()` call with the donor-corrected values for each batch.
Again, we need to set `pc.input=TRUE` to prevent the function from unnecessarily (and incorrectly) repeating the cosine normalization and PCA steps on the corrected values.
This yields a final corrected expression matrix where both within-batch donor effects and batch effects have been corrected.


```r
mnn.out3 <- fastMNN(GSE81076=mnn.out.81076$corrected,
    GSE85241=mnn.out.85241$corrected, pc.input=TRUE)
mnn.out3$batch
```

```
## character-Rle of length 3638 with 2 runs
##   Lengths:       1292       2346
##   Values : "GSE81076" "GSE85241"
```

```r
c(mnn.out.81076$batch, mnn.out.85241$batch) # by donor
```

```
## character-Rle of length 3638 with 8 runs
##   Lengths:   162   464   320   346   340   604   689   713
##   Values :   "A"   "B"   "C"   "D" "D28" "D29" "D30" "D31"
```

**Comments from Aaron:**

- `multiBatchPCA()` will ensure that each supplied matrix contributes equally to the definition of the PC space.
This avoids problems with imbalances in the number of cells across batches.
In particular, it ensures that smaller batches (possibly with unique cell types) can affect the rotation vectors.
Here, we have applied `multiBatchPCA()` to the batch-level inputs for convenience, though it is also possible to supply donor-level matrices to equalize contributions across donors.
- In this specific example, cells from the same donor will occupy contiguous rows in the `mnn.out3$corrected` matrix.
However, this may not have been the case for the original ordering of cells in each `SingleCellExperiment`.
This requires some extra account-keeping to match up the final corrected matrix to the original ordering, e.g., when cross-referencing to metadata.

    
    ```r
    original.plate <- unlist(lapply(rescaled, "[[", i="Plate"))
    original.names <- unlist(lapply(rescaled, colnames))
    
    # Needs unique names: trigger error otherwise.
    stopifnot(anyDuplicated(original.names)==0L)
    
    m <- match(rownames(mnn.out3$corrected), original.names)
    new.plate <- original.plate[m]
    ```



## Automatic specification

In situations where the nature of each batch is unknown, users can set `auto.order=TRUE` to allow `fastMNN()` to empirically choose which batches to merge at each step.
The first merge is performed between the pair of batches with the most MNN pairs.
Progressive merges are performed with the remaining batch that has the most MNN pairs with the current reference batch.
The aim is to maximize the number of MNN pairs at each step to provide a stable correction.


```r
# On 'by.donor', as 'original' only has 2 batches.
mnn.out.auto <- do.call(fastMNN, c(by.donor, 
    list(pc.input=TRUE, auto.order=TRUE)))
names(by.donor) # supplied order 
```

```
## [1] "A" "B" "C" "D"
```

```r
mnn.out.auto$order # automatically defined order
```

```
## [1] "D" "B" "C" "A"
```

The obvious cost is that of computation time. 
Nearest-neighbour searches need to be performed between all pairs of batches, and then between each remaining batch and the reference at each merge step.
As such, we prefer manual definition of a merge order that makes better use of prior knowledge about the experiment design.



# Examining the effect of correction

## By visualization

We create a new `SingleCellExperiment` object containing log-expression values for all cells, along with information regarding the batch of origin.
The MNN-corrected values are stored as dimensionality reduction results, befitting the principal components analysis performed within `fastMNN()`. 


```r
omat <- do.call(cbind, original)
sce <- SingleCellExperiment(list(logcounts=omat))
reducedDim(sce, "MNN") <- mnn.out$corrected
sce$Batch <- as.character(mnn.out$batch)

# Adjusting the rownames for easier reading.
rowData(sce)$ENSEMBL <- rownames(sce)    
rowData(sce)$SYMBOL <- mapIds(org.Hs.eg.db, keytype="ENSEMBL", 
    keys=rownames(sce), column="SYMBOL")
rownames(sce) <- uniquifyFeatureNames(rownames(sce), rowData(sce)$SYMBOL)

sce
```

```
## class: SingleCellExperiment 
## dim: 14570 3638 
## metadata(0):
## assays(1): logcounts
## rownames(14570): GCG CHGB ... RPL13AP6 CSNK1A1L
## rowData names(2): ENSEMBL SYMBOL
## colnames(3638): D2ex_1 D2ex_2 ... D30.8_93 D30.8_94
## colData names(1): Batch
## reducedDimNames(1): MNN
## spikeNames(0):
```

We examine the batch correction with some _t_-SNE plots.
Figure~\@ref(fig:tsne-batch) demonstrates how the cells separate by batch of origin in the uncorrected data.
After correction, more intermingling between batches is observed, consistent with the removal of batch effects.
Note that the E-MTAB-5601 dataset still displays some separation, which is probably due to the fact that the other batches are UMI datasets.


```r
set.seed(100)

# Using irlba to set up the t-SNE, for speed.
osce <- runPCA(sce, ntop=Inf, method="irlba")
osce <- runTSNE(osce, use_dimred="PCA")
ot <- plotTSNE(osce, colour_by="Batch") + ggtitle("Original")

# Corrected.
set.seed(100)
sce <- runTSNE(sce, use_dimred="MNN")
ct <- plotTSNE(sce, colour_by="Batch") + ggtitle("Corrected")

multiplot(ot, ct, cols=2)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/tsne-batch-1.png" alt="t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin." width="960" />
<p class="caption">(\#fig:tsne-batch)t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin.</p>
</div>

We colour by the expression of marker genes for known pancreas cell types to determine whether the correction is biologically sensible.
Cells in the same visual cluster express the same marker genes (Figure \@ref(fig:tsne-markers)), indicating that the correction maintains separation of cell types.


```r
ct.gcg <- plotTSNE(sce, colour_by="GCG") + ggtitle("Alpha cells")
ct.ins <- plotTSNE(sce, colour_by="INS") + ggtitle("Beta cells")
ct.sst <- plotTSNE(sce, colour_by="SST") + ggtitle("Delta cells")
ct.ppy <- plotTSNE(sce, colour_by="PPY") + ggtitle("PP cells")
multiplot(ct.gcg, ct.ins, ct.sst, ct.ppy, cols=2)
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/tsne-markers-1.png" alt="t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas." width="960" />
<p class="caption">(\#fig:tsne-markers)t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas.</p>
</div>

## With diagnostics

One useful diagnostic is the proportion of variance within each batch that is lost during MNN correction.
Specifically, this refers to the within-batch variance that is removed during orthogonalization with respect to the average correction vector at each merge step. 
We set `compute.variances=TRUE` to indicate to `fastMNN()` that the variance loss should be computed and returned.


```r
set.seed(1000)
with.var <- do.call(fastMNN, c(original, 
    list(k=20, d=50, approximate=TRUE, 
        compute.variances=TRUE)
))
with.var$lost.var
```

```
## [1] 0.009460765 0.012827688
```

Large proportions of lost variance suggest that correction is removing genuine biological heterogeneity.
This would occur due to violations of the assumption of orthogonality between the batch effect and the biological subspace [@haghverdi2018batch].
In this case, the proportion of lost variance is small, indicating that non-orthogonality is not a major concern.



# Using the corrected values in downstream analyses

For downstream analyses, the MNN-corrected values can be treated in the same manner as any other dimensionality reduction result.
For example, it is straightforward to use the MNN-corrected values directly used for clustering analyses, as shown below.


```r
snn.gr <- buildSNNGraph(sce, use.dimred="MNN")
clusters <- igraph::cluster_walktrap(snn.gr)
table(clusters$membership, sce$Batch)
```

```
##     
##      GSE81076 GSE85241
##   1       309      282
##   2       358      256
##   3       216      847
##   4       166      410
##   5        63      197
##   6        25      108
##   7        22      127
##   8        52       76
##   9        32        0
##   10       34        0
##   11        0       18
##   12        8        4
##   13        7       21
```

Figure \@ref(fig:tsne-cluster) shows strong correspondence between the cluster labels and separation in _t_-SNE space.


```r
sce$Cluster <- factor(clusters$membership)
plotTSNE(sce, colour_by="Cluster")
```

<div class="figure">
<img src="/home/cri.camres.org/lun01/AaronDocs/Research/simpleSingleCell/results/work-5-mnn_files/figure-html/tsne-cluster-1.png" alt="t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity." width="100%" />
<p class="caption">(\#fig:tsne-cluster)t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity.</p>
</div>

Differential expression analyses should be performed on the **original** log-expression values or counts.
We do not use the corrected values here (which no longer correspond to genes anyway) except to obtain the clusters or trajectories to be characterized.
To model the batch effect, we set the batch of origin as the `block=` argument in `findMarkers()`.
This will perform all comparisons between clusters _within_ each batch, and then combine the _p_-values to consolidate results across batches.


```r
m.out <- findMarkers(sce, clusters$membership, block=sce$Batch,
    direction="up")        
demo <- m.out[["3"]] # looking at cluster 3 (probably alpha cells).
demo <- demo[demo$Top <= 5,]
as.data.frame(demo[,1:3]) # only first three columns for brevity.
```

```
##          Top       p.value           FDR
## TM4SF4     1  0.000000e+00  0.000000e+00
## PAX6       1  0.000000e+00  0.000000e+00
## SCG5       1  0.000000e+00  0.000000e+00
## GC         1  0.000000e+00  0.000000e+00
## PPP1R1A    1  0.000000e+00  0.000000e+00
## IRX2       1  0.000000e+00  0.000000e+00
## FAP        1  0.000000e+00  0.000000e+00
## CNTN1      1  0.000000e+00  0.000000e+00
## ARX        1  0.000000e+00  0.000000e+00
## CPE        2  0.000000e+00  0.000000e+00
## CHGB       2  0.000000e+00  0.000000e+00
## SLC22A17   2  0.000000e+00  0.000000e+00
## PAM        2  0.000000e+00  0.000000e+00
## CRYBA2     2  0.000000e+00  0.000000e+00
## SYT7       2  0.000000e+00  0.000000e+00
## LOXL4      2 2.384423e-292 4.511824e-290
## PTPRN      3  0.000000e+00  0.000000e+00
## KCTD12     3  0.000000e+00  0.000000e+00
## SEZ6L2     3  0.000000e+00  0.000000e+00
## TPD52      3  0.000000e+00  0.000000e+00
## COX8A      3 7.260493e-202 6.450329e-200
## PLCE1      3 1.848381e-194 1.504520e-192
## MAFB       4  0.000000e+00  0.000000e+00
## SCGN       4  0.000000e+00  0.000000e+00
## SCG2       4  0.000000e+00  0.000000e+00
## GCG        4  0.000000e+00  0.000000e+00
## PTPRN2     4  0.000000e+00  0.000000e+00
## RAB3B      4  0.000000e+00  0.000000e+00
## SLC38A4    4  0.000000e+00  0.000000e+00
## RCAN2      4 1.062830e-284 1.843504e-282
## SLC30A8    5  0.000000e+00  0.000000e+00
## DDR1       5  0.000000e+00  0.000000e+00
## NAA20      5 1.211586e-278 2.052652e-276
## FABP5      5 1.775700e-268 2.613329e-266
## CFC1       5 3.044406e-266 4.435700e-264
```



Other approaches for handling batch effects during marker gene detection are discussed [elsewhere](https://bioconductor.org/packages/3.9/simpleSingleCell/vignettes/xtra-3b-de.html#blocking-on-uninteresting-factors-of-variation).
It is similarly possible to perform these analyses with standard Bioconductor packages for DE analysis such as *[edgeR](https://bioconductor.org/packages/3.9/edgeR)* or *[limma](https://bioconductor.org/packages/3.9/limma)*.
Note that the use of `block=` is roughly similar to the use of a batch-cluster interaction model and testing whether the average log-fold change across batches is equal to zero.

**Comments from Aaron:**

- Users of the older `mnnCorrect()` function will note that the function returned corrected _expression_ values.
Thus, it is tempting to use these corrected values directly for DE analyses.
This is inappropriate for various reasons:
    - The default parameters of `mnnCorrect()` do not return corrected values on the log-scale, but rather a cosine-normalized log-scale.
      This makes it difficult to interpret the effect size of DE analyses based on the corrected values.
    - It is usually inappropriate to perform DE analyses on batch-corrected values, due to the failure to model the uncertainty of the correction.
      This usually results in loss of type I error control, i.e., more false positives than expected.
    - The correction does _not_ preserve the mean-variance relationship.

# Concluding remarks

We save the `SingleCellExperiment` object for use elsewhere.
This avoids the need to repeat all of the processing steps described above.


```r
saveRDS(file="pancreas_data.rds", sce)
```

All software packages used in this workflow are publicly available from the Comprehensive R Archive Network (https://cran.r-project.org) or the Bioconductor project (http://bioconductor.org).
The specific version numbers of the packages used are shown below, along with the version of the R installation.


```r
sessionInfo()
```

```
## R Under development (unstable) (2018-11-02 r75535)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.5 LTS
## 
## Matrix products: default
## BLAS: /home/cri.camres.org/lun01/Software/R/trunk/lib/libRblas.so
## LAPACK: /home/cri.camres.org/lun01/Software/R/trunk/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
##  [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
##  [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] scran_1.11.1                scater_1.11.2              
##  [3] ggplot2_3.1.0               SingleCellExperiment_1.5.0 
##  [5] SummarizedExperiment_1.13.0 DelayedArray_0.9.0         
##  [7] BiocParallel_1.17.1         matrixStats_0.54.0         
##  [9] GenomicRanges_1.35.0        GenomeInfoDb_1.19.0        
## [11] org.Hs.eg.db_3.7.0          AnnotationDbi_1.45.0       
## [13] IRanges_2.17.1              S4Vectors_0.21.1           
## [15] Biobase_2.43.0              BiocGenerics_0.29.1        
## [17] bindrcpp_0.2.2              BiocFileCache_1.7.0        
## [19] dbplyr_1.2.2                knitr_1.20                 
## [21] BiocStyle_2.11.0           
## 
## loaded via a namespace (and not attached):
##  [1] dynamicTreeCut_1.63-1    viridis_0.5.1           
##  [3] httr_1.3.1               edgeR_3.25.0            
##  [5] bit64_0.9-7              viridisLite_0.3.0       
##  [7] DelayedMatrixStats_1.5.0 assertthat_0.2.0        
##  [9] statmod_1.4.30           highr_0.7               
## [11] BiocManager_1.30.3       blob_1.1.1              
## [13] vipor_0.4.5              GenomeInfoDbData_1.2.0  
## [15] yaml_2.2.0               pillar_1.3.0            
## [17] RSQLite_2.1.1            backports_1.1.2         
## [19] lattice_0.20-38          limma_3.39.1            
## [21] glue_1.3.0               digest_0.6.18           
## [23] XVector_0.23.0           colorspace_1.3-2        
## [25] cowplot_0.9.3            htmltools_0.3.6         
## [27] Matrix_1.2-15            plyr_1.8.4              
## [29] pkgconfig_2.0.2          bookdown_0.7            
## [31] zlibbioc_1.29.0          purrr_0.2.5             
## [33] scales_1.0.0             HDF5Array_1.11.0        
## [35] Rtsne_0.15               tibble_1.4.2            
## [37] withr_2.1.2              lazyeval_0.2.1          
## [39] magrittr_1.5             crayon_1.3.4            
## [41] memoise_1.1.0            evaluate_0.12           
## [43] beeswarm_0.2.3           tools_3.6.0             
## [45] stringr_1.3.1            Rhdf5lib_1.5.0          
## [47] locfit_1.5-9.1           munsell_0.5.0           
## [49] irlba_2.3.3              compiler_3.6.0          
## [51] rlang_0.3.0.1            rhdf5_2.27.0            
## [53] grid_3.6.0               RCurl_1.95-4.11         
## [55] BiocNeighbors_1.1.1      rappdirs_0.3.1          
## [57] igraph_1.2.2             labeling_0.3            
## [59] bitops_1.0-6             rmarkdown_1.10          
## [61] gtable_0.2.0             DBI_1.0.0               
## [63] curl_3.2                 reshape2_1.4.3          
## [65] R6_2.3.0                 gridExtra_2.3           
## [67] dplyr_0.7.8              bit_1.1-14              
## [69] bindr_0.1.1              rprojroot_1.3-2         
## [71] stringi_1.2.4            ggbeeswarm_0.6.0        
## [73] Rcpp_1.0.0               tidyselect_0.2.5        
## [75] xfun_0.4
```

# References

